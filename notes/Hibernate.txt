Hibernate core implements JPA
After success of Hibernate, team came up to standardize Hibernate as part of JPA.
So, JPA came after Hibernate. So, that it will be easy to switch between the DB's.
Hibernate has more features then JPA
Entity needs parameter less constructor
 javax.persistence.*, then you are using jpa, if from org.hibernate*, then hibernate.

JdbcTemplate -> jdbc
EntityManager -> JPA

EntityManager is a interface to Persistence Context: all the capgemini.entities
                which are saved by EM is being saved in the PC. PC keeps track all the capgemini.entities
                changed during the Transaction

EM will persist all the changes in persistence context till the end of the Transaction. At the end of the
    Transaction EM will push the changes to DB.

In TM need to take case 4 properties:
ACID:
Atomicity: all the operations executed successfully
Consistency: system must be in consistent.
             Like in a bank If A -> transfer money to -> b then -> total balance in the bank must be -> same.
Isolation: Transaction visibility to the other transactions
Durability: Any change from the transaction must be persisted

When to use JPA and JDBC
 JDBC: when we don't need to track the object. Object oriented approach is not required.
 JPA: when we need to track the object behaviour. Object oriented approach is required.

If you are someone who like interface-based-implementation, then JPA is the interface definition
    and Hibernate is one of the implementations.
 We decided to use JPA semantics in our project (with a very long term plan to replace Hibernate with something similar and light-weight
 probably).
 If you want to stick to hibernate in future, then no point in using EntityManagerFactory, you can go ahead and use SessionFactory.

			Java Persistence API																			Hibernate
JPA is responsible for managing relational databases in Java applications.	|||| Hibernate is an ORM tool used for saving the state of the Java object in the database.
It is defined under the javax.persistence package.								 It is defined under org.hibernate package.
JPA is the Java specification and not the implementation.						 Hibernate is an implementation of JPA and uses common standards of Java Persistence API.
It uses the EntityManagerFactory interface to interact with the entity			 It uses the SessionFactory interface for creating Session instances.
	manager factory for the persistence unit. 									 It uses a Session interface to create, read, and delete operations forIt uses the EntityManager interface to create, read, and delete
operations for instances of mapped entity classes. This interface 				 instances of mapped entity classes. It behaves as a runtime interface between
interacts with the persistence context.											  a Java application and Hibernates.
JPQL																			 HQL


Advantages of JPA
	The burden of interacting with the database reduces significantly by using JPA.
	The programming task becomes easy by using O/R mapping and database access processing.
	Annotations reduce the code of creating definition files.
	Using different implementations can add the features to the standard implementation which can later be the part of JPA specification.

Disadvantages of JPA
	JPA specification may need to go through important developments before it becomes stable.
	JPA is not a product but a specification, so you need a provider to provide an implementation
	    so that you can gain the benefits of these standards-based APIs.

Advantages of Hibernate
	Hibernate supports Inheritance, Associations, and Collections.
	Hibernate can generate primary keys automatically while we are storing the records in the database.
	Hibernate has its query language, i.e., Hibernate query language, which is database-independent, so if you change the database, then also our application will work as HQL is database independent.
	Hibernate provides Dialect classes, so you do not need to write SQL queries in hibernate. Instead, we use the methods provided by that API.

Disadvantages of Hibernate
	The performance of Hibernate is not good with batch processing, so it is advised to go with pure JDBC in these cases.
	Having mappings and joins among the tables makes it difficult to understand the code as we need to define the mapping and enter information in the XML file.
	A small project will have fewer tables, and introducing the entire Hibernate framework will be overhead than helpful.
	Hibernate does not allow some queries which JDBC supports. A developer has to write a separate query to insert each object.

Jakarta Persistence Layer (JPL) is the successor to JPA and is part of the Jakarta EE specifications.
	It is built upon JPA and provides similar functionality for managing relational data in Java applications.
	The primary difference is the change of package names, from javax. persistence to jakarta.

Persist / Save

Persist():
    1. Syntax: public void persist(Object object) throws HibernateException.
    2. It does not returns generated Id after saving. Its return type is void.
    3. Persist method can be used only within the transaction.
    4. session.persist() for a detached object will throw PersistentObjectException as it is not allowed.
    5. Persist method takes less time to execute.

Save():
    1. Syntax: public Serializable save(Object object) throws HibernateException.
    2. The return type of the save method is java.io.Serializable. It returns the generated Id after saving the record.
    3. It can save the changes to the database outside of the transaction. i.e. Save method can be used inside or outside the transaction.
    4. Session.save() for a detached object will create a new row in the table.
    5. Save method takes more time to execute.

States of Entity Instances
    Any entity instance in our application appears in one of the three main states in relation to the Session persistence context:
        transient — This instance isn't, and never was, attached to a Session. This instance has no corresponding rows in the database; it's usually just a new object that we created to save to the database.
        persistent — This instance is associated with a unique Session object. Upon flushing the Session to the database, this entity is guaranteed to have a corresponding consistent record in the database.
        detached — This instance was once attached to a Session (in a persistent state), but now it’s not. An instance enters this state if we evict it from the context, clear or close the Session, or put the instance through serialization/deserialization process.