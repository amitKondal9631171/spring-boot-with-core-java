 ArrayList is backed by array
 LinkedList is backed by a linked list (nodes) which means search with index is only
    possible in ArrayList.

Priority queue is different from "normal" queue. Instead of "First-In-First-Out",
    it retrieves the items in order of their priority.

TreeSet is a sorted set where elements are stored in their natural or custom
    sorting order depending upon comparable and comparator while LinkedHashSet
    is just an ordered collection that maintains insertion order.

IdentityHashMap: implements the Map interface using Hashtable,
                comparing keys (and values) using reference equality instead of object equality.
                This class implements the Map interface, but it intentionally breaks Map’s
                    general contract, which demands that objects are compared using the equals()
                    method.
                This class is used when the user allows objects to be compared using references.

Enumeration is twice as fast as Iterator and uses very little memory. Enumeration is very basic and
    fits basic needs. But the Iterator is much safer as compared to Enumeration because it always
    denies other threads to modify the collection object which is being iterated by it.
    Iterator takes the place of Enumeration in the Java Collections Framework.
    Iterators allow the caller to remove elements from the underlying collection that is not possible
    with Enumeration. Iterator method names have been improved to make its functionality clear.

Collection interface specifies group of Objects known as elements. How the elements are maintained is
    left up to the concrete implementations of Collection. For example, some Collection implementations
    like List allow duplicate elements whereas other implementations like Set don't.
    A lot of the Collection implementations have a public clone method. However, it doesn't make
    sense to include it in all implementations of Collection. This is because Collection is an
    abstract representation. What matters is the implementation. The semantics and the implications
    of either cloning or serializing come into play when dealing with the actual implementation;
    so concrete implementation should decide how it should be cloned or serialized, or even if it
    can be cloned or serialized. So mandating cloning and serialization in all implementations is
    less flexible and more restrictive. The specific implementation should decide as to whether it
    can be cloned or serialized.

HashMap and Hashtable both implements Map interface and looks similar, however, there is the following difference between HashMap and Hashtable.
1.  HashMap allows null key and values whereas Hashtable doesn't allow null key and values.
2.  Hashtable is synchronized but HashMap is not synchronized. So HashMap is better for single threaded
    environment, Hashtable is suitable for multi-threaded environment.
3.  `LinkedHashMap` was introduced in Java 1.4 as a subclass of HashMap, so incase you want iteration
        order, you can easily switch from HashMap to LinkedHashMap but that is not the case with Hashtable
        whose iteration order is unpredictable.
4.  HashMap provides Set of keys to iterate and hence it's fail-fast but Hashtable provides Enumeration
    of keys that doesn't support this feature.

Why can’t we write code as List<Number> numbers = new ArrayList<Integer>(); ?
    Generics doesn't support sub-typing because it will cause issues in achieving type safety.
        That's why List<T> is not considered as a subtype of List<S> where S is the super-type of T.
        To understanding why it's not allowed, let's see what could have happened if it has been supported.
        List<Long> listLong = new ArrayList<Long>();
        listLong.add(Long.valueOf(10));
        List<Number> listNumbers = listLong; // compiler error
        listNumbers.add(Double.valueOf(1.23));
        As you can see from above code that IF generics would have been supporting sub-typing,
            we could have easily add a Double to the list of Long that would have caused
            `ClassCastException` at runtime while traversing the list of Long.

We are not allowed to create generic arrays because array carry type information of its elements at runtime.
    This information is used at runtime to throw `ArrayStoreException` if elements type doesn't match to
    the defined type. Since generics type information gets erased at compile time by Type Erasure, the
    array store check would have been passed where it should have failed. Let's understand this with a
    simple example code.
    List<Integer>[] intList = new List<Integer>[5]; // compile error
    Object[] objArray = intList;
    List<Double> doubleList = new ArrayList<Double>();
    doubleList.add(Double.valueOf(1.23));
    objArray[0] = doubleList; // this should fail but it would pass because at runtime intList and doubleList both are just List

for (;;) // Infinite loop
            System.out.println("Test");