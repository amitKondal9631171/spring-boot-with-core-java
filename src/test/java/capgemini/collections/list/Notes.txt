

Why is there no TreeList implementation of the List interface?
    Basically you need to understand what is the purpose of these implementation like both
        these TreeMap and Treeset are implementation of SortedSet and SortedMap is used for
        sorting purpose but we have Collections.sort(List) which can be implied on List for
        sorting hence not TreeList is not required in List.
    Because a list is an index-based data structure, and trees are no index-based data
        structures. That's the most basic and clear reason.


ğŸ”¹ 1. Underlying Data Structure
        ArrayList â†’ Dynamic array (resizable array).
        LinkedList â†’ Doubly-linked list (each node has references to prev & next).
ğŸ”¹ 2. Access Time (Read/Search)
        ArrayList â†’ O(1) for random access (get(index)), since itâ€™s an array.
        LinkedList â†’ O(n) for access, because you must traverse nodes sequentially.
    ğŸ‘‰ If you need frequent reads, use ArrayList.
ğŸ”¹ 3. Insertion/Deletion
    ArrayList
        Adding at end â†’ Amortized O(1).
        Adding/removing at middle/start â†’ O(n) (because elements must shift).
      LinkedList
        Adding/removing at start or middle (when iterator is available) â†’ O(1).
        Finding the right index before insertion still takes O(n).
         ğŸ‘‰ If you need frequent insertions/deletions in the middle/start, use LinkedList.
ğŸ”¹ 4. Memory Usage
        ArrayList â†’ Less memory overhead (just elements).
        LinkedList â†’ More memory overhead (each node stores data + 2 pointers).
ğŸ”¹ 5. Iteration
        ArrayList â†’ Better cache locality â†’ faster iteration.
        LinkedList â†’ Slower iteration due to scattered memory references.
ğŸ”¹ 6. Use as Queue/Stack
        ArrayList â†’ Not efficient for queue/stack operations (except add() at end).
        LinkedList â†’ Implements Deque â†’ can be used as both Queue (FIFO) and Stack (LIFO) efficiently.
ğŸ”¹ 7. Thread Safety
        Both are not synchronized. If you need thread safety, use Collections.synchronizedList() or CopyOnWriteArrayList.


 Rule of Thumb:
    ArrayList â†’ Best for search-heavy use cases.
    LinkedList â†’ Best for insert/delete-heavy use cases.

 4ï¸âƒ£ Summary
            Approach	                                            Why / Why Not
     Deque<Integer> stack = new LinkedList<>();	            Works, but slower and uses more memory
     Deque<Integer> stack = new ArrayDeque<>();	            Preferred, faster and cleaner
     Stack<Integer> stack = new Stack<>();	                Outdated; Stack is synchronized and slower


| Feature                     | `Collections.unmodifiableList(list)`   | `List.of(...)`                           |
| --------------------------- | -------------------------------------- | ---------------------------------------- |
| **Immutability**            | âŒ Not true immutability (wrapper only) | âœ… Fully immutable                        |
| **Reflects Source Changes** | âœ… Yes                                  | âŒ No                                     |
| **Null Support**            | âœ… Allowed                              | âŒ Not allowed                            |
| **Thread Safety**           | âŒ No (depends on underlying list)      | âœ… Yes (immutable by nature)              |
| **Java Version**            | Java 5+                                | Java 9+                                  |
| **Performance**             | Slightly slower due to wrapper check   | Faster due to direct immutable structure |


| Operation                         | **ArrayList**                          | **CopyOnWriteArrayList**             |
| --------------------------------- | -------------------------------------- | ------------------------------------ |
| **Read**                          | Very fast                              | Slightly slower (but snapshot-safe)  |
| **Write (add/remove)**            | Very fast                              | Slower (copies array on every write) |
| **Iteration during modification** | `ConcurrentModificationException` risk | Safe â€” iterates over snapshot        |
