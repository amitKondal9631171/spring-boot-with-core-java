Object-relational mapping or ORM is the programming technique to map
    application domain model objects to the relational database tables.
Hibernate provides reference implementation of Java Persistence API.
Java Persistence API (JPA) provides specification for managing the relational data in applications.

Lazy initialization is achieved with proxy objects as object is only loaded whenever it is required.
Hibernate cache
provides hql which is fully object oriented.
Easy to integrate with the j2ee applications.
Important interfaces used in hibernate:
	Session Factory: use to read the hibernate configuration file and connect to the db.
					immutable, single for whole application, thread safe, initialized
					only once and cached and reused again and again. Session factory instance is used to get the
					session object.
	Session: is single threaded short lived object. it wraps the db connection so whenever we open the session it
	            requires to be closed.
	Transaction: single threaded and short lived object used to define the unit of work.
	
Hibernate config file contains the db specific details and used to initialize the session factory. we give the db
    details of JNDI resource information in the config file.

What is difference between openSession and getCurrentSession?
	1) getCurrentSession() method returns the session bound to the context.	
							Since this session object belongs to the hibernate context, we don’t need to close it.
							Once the session factory is closed, this session object gets closed.
	2) openSession() method always opens a new session. We should close this session object once we are done with all the database operations. 
--> Get() fetches the data from database whereas load() returns a proxy object and loads data only when it’s actually required, 
			so load() is better because it support lazy loading.
	Since load() throws exception when data is not found, we should use it only when we know data exists.
	We should use get() when we want to make sure data exists in the database.
	Get It object not found for the given identifier then it will return null object 
	It returns fully initialized object so this method eager load the object  
	
	load returns the proxy object.
	Load: If you are sure that object exist then use load() method 

--> Hibernate Cache is used to increase the application performance as it reduce the db calls.
	There are two types of cache:
		First level cache is associated with the Session object. Any object associated with session will not be visible to the other session.
		 and whenever session is closed the object also lost.
		Second level cache: is associated with session factory and available to all sessions.
							by  default it is disabled.
--> Transient: When an object is never persisted or associated with any session, it’s in transient state.
	Persistent: When an object is associated with a unique session, it’s in persistent state.
	Detached: When an object is previously persistent but not associated with any session, it’s in detached state.

--> Why we should not make Entity Class final?
	Hibernate use proxy classes for lazy loading of data, only when it’s needed. This is done by extending the
	entity bean, if the entity bean will be final then lazy loading will not be possible, hence low performance.

--> Hibernate provides Criteria API that is more object oriented for querying the database and getting results.
	We can’t use Criteria to run update or delete queries

--> Hibernate uses proxy object to support lazy loading.

--> When we have relationship between entities, then we need to define how the different operations will affect the other entity. 
	This is done by cascading and there are different types of it.	
--> SQL injection is a type of sql attack that makes it possible to execute unwanted sql statements.
--> Db procedures are used for security reasons.
	Use to process huge amount of data.
	For faster execution
	used for reducing network traffic.
	These are used to encapsulate the logic and hence the code can be changed without affecting the clients.
	SQL injection attacks can be avoided using this.
	Types:
		User-defined stored procedures
		Extended stored procedures
		System stored procedures: used for administrative purposes
--> When select sql is executed then database create memory area known as context area. A cursor is a pointer to
         context area. It contains all information need to execute the statement. Context area is controlled by the
         cursor.

	Types of cursor:
		Implicit: automatically generated by database while statement is executed.
					These are created by default to process the statements when DML statements
					like INSERT, UPDATE, DELETE etc. are executed.
					Oracle provides some attributes known as Implicit cursor's attributes to check the status of DML operations. Some of them are: %FOUND, %NOTFOUND, %ROWCOUNT and %ISOPEN.
		Explicit: The Explicit cursors are defined by the programmers to gain more control over the context area.
					Steps:
					Declare the cursor to initialize in the memory.
					Open the cursor to allocate memory.
					Fetch the cursor to retrieve data.
					Close the cursor to release allocated memory.
					
			E.g:	DECLARE  
					   c_id customers.id%type;  
					   c_name customers.name%type;  
					   c_addr customers.address%type;  
					   CURSOR c_customers is  
						  SELECT id, name, address FROM customers;  
					BEGIN  
					   OPEN c_customers;  
					   LOOP  
						  FETCH c_customers into c_id, c_name, c_addr;  
						  EXIT WHEN c_customers%notfound;  
						  dbms_output.put_line(c_id || ' ' || c_name || ' ' || c_addr);  
					   END LOOP;  
					   CLOSE c_customers;  
					END;  
					/  
	Materialize view: https://www.java67.com/2012/11/what-is-difference-between-view-vs-materialized-view-database-sql.html


Statement – Used to execute string-based SQL queries
PreparedStatement – Used to execute parameterized SQL queries
PreparedStatement is child of statement class
PreparedStatement can bind various data types like string int etc.
pre compiled.


Union: combines the records of two tables and removes the duplicate records
Union ALL: combines the records of two table without removing the duplicate records.